#!/usr/bin/env node
'use strict';
/**
 * Fake Daemon
 *
 * For service production script, you should use `./bin/cli` instead of `./bin/gina`
 *
 * Usage:
 * $ gina <topic>:<task> <arguments>
 *
 * eg.:
 * Start the server
 * $ gina start
 * or
 * $ gina framework:start
 *
 * Start & debug the server (only)
 * $ gina start --inspect-gina
 *
 * Stop the server
 * $ gina stop
 *
 * Start a bundle
 * $ gina bundle:start demo @myproject
 *
 * For zsh, if we want to hide all outputs
 * $ gina start  >&/dev/null &!
 */
var fs      = require('fs');
const {spawn}   = require('child_process');
const {execSync}   = require('child_process');

var restartPid = null;

function runAsSubProcess() {

    var argv            =  Array.from(process.argv);
    var nodeBin         = execSync('which node').toString().trim();
    var cliBin          = __dirname + '/cli';
    var fakeDaemonPid   = '--fake-daemon-pid='+ process.pid;

    if ( argv.indexOf('--inspect-gina') > -1 ) {
        cliBin  = __dirname + '/cli-debug';
        argv.splice(argv.indexOf('--inspect-gina'), 1);
        // removing `--inspect-gina`
        Array.prototype.splice.call(process.argv, argv.indexOf('--inspect-gina'), 1);
    }

    argv.splice(0, 0, cliBin);
    argv.splice(argv.length, 0, fakeDaemonPid);

    // overriding process.argv which is used in `./cli`
    Array.prototype.splice.call(process.argv, 0, 0, nodeBin);
    Array.prototype.splice.call(process.argv, 0, 0, cliBin);
    Array.prototype.splice.call(process.argv, process.argv.length, 0, fakeDaemonPid);

    var child = spawn(nodeBin, argv,
        {
            detached: true
        }
    );
    var pid = null;

    // set encoding
    child.stdout.setEncoding('utf8');
    child.stdout.on('data', function(data) {

        // Uncomment if you want all the noise to debug
        // TODO - Allow if `GINA_ENV_IS_DEV` == true
        // check `~/.gina/{shortVersion}/settings.json`
        process.stdout.write(data);

        /**
         * Filter messages from Logger
         */

        // Normal case
        if ( new RegExp('Framework ready for connections','gmi').test(data) ) {
            console.info('Gina server started with PID `'+ child.pid +'`');
            // sending kill command to parent restart process
            if (restartPid) {
                // we can't just use process.kill() here ...
                process.stdout.write('[ quit ]\n');
            }
            // Do not use `process.exit(0)` right away or the framework PID file will be removed
            // after bundle:start, and only God knows whatever shit is going to happen
            // Make a pause until the CLI tels otherwise (process.kill(cmd.pid, 'SIGCONT');)
            // Docker considerations: All signals except for SIGKILL and SIGSTOP can be intercepted by the process.
            // Ref.: https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86


            process.kill(process.pid, 'SIGSTOP');
            // Docker fix - 2022-08-20
            // process.kill(process.pid, 'SIGABRT');
            // process.exit(0);
            return;
        }

        // If framework is already running
        if ( new RegExp('Framework already running','gmi').test(data) ) {
            pid = ''+data.match(/\[\s+\d+\s+\]/);
            if (pid && pid.length > 0) {
                if (Array.isArray(pid) ) {
                    pid = pid[0].replace(/\[|\]|\s+/g, '');
                } else {
                    pid = pid.replace(/\[|\]|\s+/g, '');
                }

                console.info('Gina server is already running with PID `'+ pid +'`');
            } else {
                console.info('Gina server is already running');
            }

            process.exit(0);
        }

    });

    //when an exception is thrown, it is sent to the client
    child.stderr.setEncoding('utf8');
    var error = null;
    child.stderr.on('data', function(err) {
        error = err.toString();
        if (/Debugger listening|Debugger attached|Warning|address already in use/i.test(error)) {
            console.warn(error);
            return process.exit(1);
        }
        console.error(error);
    });

    //  TODO - Remove this, we should be able to check the logs in case of troubles
    child.on('exit', function(code, signal) {
        // handles only signals that cannot be cannot be caught or ignored
        // ref.: `framework/<version>/lib/proc.js`
        if (/(SIGKILL|SIGSTOP)/i.test(signal)) {
            console.emerg('[' + this.pid + '] exiting with signal: ', signal);
        }
    });
}

/**
 * Will spawn gina CLI with its arguments
 * This is done to allow gina to run in background
 * NB.: If you want to use gina as a daemon, do not point to this file
 *      Use `./bin/cli` instead
*/
function runCMD() {
    var argv = Array.from(process.argv);
    // BO - filter restartPid
    var r = 0;
    for (let i=0, len=process.argv.length; i<len; i++) {
        let arg = process.argv[i];
        if ( /\-\-restart\-pid/.test(arg) ) {
            restartPid = ~~(arg.split(/\=/)[1]);
            r = i;
            break;
        }

    }
    if (restartPid) {
        console.debug('removing `--restart-pid`: '+ restartPid);
        // removing `--restart-pid`
        Array.prototype.splice.call(process.argv, r, 1);
    }
    // EO - filter restartPid

    if ( /^(start|framework:start)$/.test(argv[2]) ) {
        try {
            // Filter args
            process.argv = Array.prototype.splice.call(process.argv, 2);
            runAsSubProcess.apply(null);
            return;
        } catch (cmdErr) {
            throw cmdErr
        }
    }
    // Normal command lines
    var cliBin  = __dirname + '/cli';
    if ( argv.indexOf('--inspect-gina') > -1 ) {
        cliBin  = __dirname + '/cli-debug';
        argv.splice(argv.indexOf('--inspect-gina'), 1);
        Array.prototype.splice.call(process.argv, argv.indexOf('--inspect-gina'), 1);
    }
    require(cliBin);
}

runCMD();