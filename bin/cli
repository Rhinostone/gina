#!/usr/bin/env node
'use strict';

var fs  = require('fs');
var net = require('net');


var isWin32     = (process.platform === 'win32') ? true : false;
var binPath     = __dirname;
var ginaPath    = (binPath.replace(/\\/g, '/')).replace('/bin', '');
ginaPath = (isWin32) ? ginaPath.replace(/\//g, '\\') : ginaPath;

var help        = require(ginaPath + '/utils/helper.js');
// loading pack
var pack        = ginaPath + '/package.json';
pack            =  (isWin32) ? pack.replace(/\//g, '\\') : pack;


try {
    var packObj         = require(pack);
    var version         = getEnvVar('GINA_VERSION') ||Â packObj.version;
    var frameworkPath   = ginaPath + '/framework/v' + version;

    require(frameworkPath + '/lib');
    var aliases     = require(frameworkPath + '/lib/cmd/aliases.json');

    //Loading logger.
    var console = lib.logger;

    if ( !fs.existsSync(frameworkPath) ) {
        console.alert('Could not find version ' + version + '.\nFirst try:\n$ gina framework:install ' + version);
        process.exit(1)
    }

    try {
    } catch (err) {
        console.alert("Package.json is missing or corrupted.\n", err.stack);
        process.exit(1)
    }
} catch (err) {
    process.stdout.write('gina: could not load [ ' + pack + ' ]\n' + err.stack);
    process.exit(1)
}

// catching debug|inspect arg
var debugPort           = null
    , debugBrkEnabled   = null
    , params            = process.argv
;
if ( params.length > 0 ) {
    for (var p = 0, len = params.length; p < len; ++p) {
        if ( /^\-\-(inspect|debug)/.test(params[p]) ) {
            debugBrkEnabled = ( /\-brk/.test(params[p]) ) ? true : false;
            debugPort       = params[p].split(/\=/)[1];
            params.splice(p,1);            
            break;
        }
    }
}
filterArgs();
//check for $HOME path, alert if empty.
var home = getUserHome();
if (!home) {
    console.error('No ' + ((isWin32) ? 'USERPROFILE' : 'HOME') + ' path found.')
} else {

    setEnvVar('GINA_VERSION', version);

    var shortVersion = version.split('.');
    shortVersion.splice(2,1);
    shortVersion = shortVersion.join('.');
    setEnvVar('GINA_SHORT_VERSION', shortVersion);

    setEnvVar('GINA_HOME', home);
    setEnvVar('GINA_DIR', ginaPath);
    setEnvVar('GINA_FRAMEWORK_DIR', frameworkPath);

    if ( typeof(getEnvVar('GINA_HOMEDIR')) == 'undefined') {
        setEnvVar('GINA_HOMEDIR', home + '/.gina')
    }
    home = getEnvVar('GINA_HOMEDIR')
}
setEnvVar('GINA_IS_WIN32', isWin32, true);



/**
 * Framework port
 * */
var port = 8124;

// |-> framework/{version}/lib/cmd
var allowedOffline = [
    'dev:',
    'env:',
    'framework:',
    'project:',
    'bundle:',
    'port:',
    'protocol:',
    'scheme:',
    'view:',
    '--', //options or other aliases.
    '-' //options or other aliases.
];

if ( process.argv.count() < 3 ) {
    if (isWin32)
        console.log('Check out the help section:\n$ gina -h')
    else
        console.log('Check out the manpage:\n$ man gina')

    process.exit(0)
}

if (process.argv[2].indexOf(':') < 0) {
    process.argv[2] = 'framework:' + process.argv[2];
}

if (
    typeof(process.argv[2]) != 'undefined'
        && process.argv[2] === 'start'
    || typeof(process.argv[2]) != 'undefined'
        && process.argv[2] === 'framework:start'
) {

    //Start framework || launch online CMD.
    require(binPath + '/cmd')({
        binPath         : binPath,
        ginaPath        : ginaPath,
        frameworkPath   : frameworkPath,
        homedir         : home,
        port            : port,
        debugPort       : debugPort,
        debugBrkEnabled : debugBrkEnabled,
        pack            : pack
    })

} else if (
    typeof(process.argv[2]) != 'undefined'
    && allowedOffline.indexOf( (process.argv[2].split(':')[0] + ':')) > -1
    &&  process.argv[2] !== 'bundle:start'
    || process.argv[2].substr(0, 2) === '--'
    || process.argv[2].substr(0, 1) === '-'
) {
    // if (debugPort) {
        
    //     process.argv[0] = process.argv[0].replace(/node$/, function(str){ return str+' --inspect-brk='+ debugPort });
    //     console.log('arg 0', process.argv[0]);
    // }
    require(binPath + '/cmd')({
        binPath         : binPath,
        ginaPath        : ginaPath,
        frameworkPath   : frameworkPath,
        homedir         : home,
        port            : port,
        debugPort       : debugPort,
        debugBrkEnabled : debugBrkEnabled,
        pack            : pack
    }, true)

} else if ( typeof(process.argv[2]) != 'undefined'
            && allowedOffline.indexOf( (process.argv[2].split(':')[0] + ':')) < 0
) {
    // check allowedOffline ;)
    process.argv.splice(0,2);
    console.error( '[ $ gina ' + process.argv.join(' ') + ' ] is not a valid command line' )
} else {

    //Connect to framework.
    var client = net.connect({port: port},
        function() {
            //Forwarding cmd.
            // retieving debug infos
            var debugOption = null;
            if ( debugPort ) {
                debugOption = '--inspect=' + debugPort;     
                    
                if (debugBrkEnabled) {
                    debugOption = debugOption.replace(/\-\-inspect/, '--inspect-brk')
                }
                
                process.argv.push(debugOption)
            }
            
            client.write( JSON.stringify(process.argv) );
        }
    );

    client.on('data', function(data) {
        
        //Acknowledging ready state.
        if (  /\[ quit \]/.test(data) ) {
            client.end()
        } else {
            console.log( data.toString() + '\n');
        }
    });

    //client end event.
    client.on('end', function() {
        process.exit(0)
    });

    client.on('error', function(err) {
        if (isWin32) {
            console.log('[ gina ] not started, try to start framework as Administrator :\n$ gina start')
        } else {
            console.log('[ gina ] not started, try to start framework with :\n$ sudo gina start')
        }
        //if ( getEnvVar('GINA_ENV_IS_DEV') ) {
            console.debug(err.stack||err)
        //}
        
        process.exit(1)
    });    
}